Index: ode.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import warnings\r\nimport numpy as np\r\nimport math\r\nimport sklearn\r\nimport matplotlib\r\nfrom matplotlib import pyplot as plt\r\nfrom matplotlib import cm\r\nfrom scipy.optimize import curve_fit\r\nfrom sklearn.linear_model import BayesianRidge\r\n\r\nfrom plotting import *\r\nfrom gradient_descent_complete import *\r\nfrom gradient_descent_complete import gaussian3D as obj\r\n\r\ndef ode_model(t, p, q, a, b, c, p0, p1):\r\n    \"\"\"ODE model for aquifer pressure.\r\n    \r\n    Parameters\r\n    ----------\r\n    t : float\r\n        Time.\r\n    p : float\r\n        Aquifer pressure.\r\n    q : float\r\n        Extraction rate.\r\n    a : float\r\n        Extraction parameter.\r\n    b : float\r\n        Recharge parameter.\r\n    c : float\r\n        Saltwater intrusion parameter.\r\n    p0 : float\r\n        Pressure of freshwater spring.\r\n    p1 : float\r\n        Pressure of ocean.\r\n    \r\n    Returns\r\n    -------\r\n    dpdt : float\r\n        Derivative of aquifer pressure with respect to time.\r\n    \"\"\"\r\n\r\n    dpdt = -a*q - b*(p - p0) - c*(p - p1)\r\n    return dpdt\r\n\r\ndef load_data():\r\n    \"\"\" Load data throughout the time period.\r\n    Parameters:\r\n    -----------\r\n    Returns:\r\n    ----------\r\n    t_q : array-like\r\n        Vector of times at which measurements of q were taken.\r\n    q : array-like\r\n        Vector of q (kg/year)\r\n    p_x : array-like\r\n        Vector of times at which measurements of p were taken.\r\n    p : array-like\r\n        Vector of p (MPa)\r\n    \"\"\"\r\n    # Load kettle data\r\n    t_step_p, p = np.genfromtxt('P_acquifer.csv', delimiter=',', skip_header=1).T\r\n    t_step_q, q = np.genfromtxt('q_acquifer.csv', delimiter=',', skip_header=1).T\r\n\r\n    # # calibration step of 70%\r\n    # lengthp = len(p)\r\n    # calbp = round(0.7 * lengthp - 1)\r\n    # t_step_p = t_step_p[0:calbp]\r\n    # p = p[0:calbp]\r\n\r\n    # # calibration step of 70% from 1990\r\n    # lengthq = len(q) - 30\r\n    # calbq = round(0.7 * lengthq - 1)\r\n    # t_step_q = t_step_q[30:calbq + 30]\r\n    # q = q[30:calbq + 30]\r\n\r\n    # Pressure of the aquifer\r\n    p += 0.101\r\n\r\n    # Convert q to kg/s\r\n    q /= 31536000\r\n\r\n    # Convert to Pa?\r\n    # p *= 1000000\r\n\r\n    # Convert to SI units\r\n    # t_step_p *= 31536000\r\n    # t_step_q *= 31536000\r\n    # p *= 1000000\r\n\r\n    return t_step_q, q, t_step_p, p\r\n\r\n# This function solves your ODE using Improved Euler\r\ndef solve_ode(f, t0, t1, dt, xi, pars):\r\n    \"\"\" Solve an ODE using the Improved Euler Method.\r\n    Parameters:\r\n    -----------\r\n    f : callable\r\n        Function that returns dxdt given variable and parameter inputs.\r\n    t0 : float\r\n        Initial time of solution.\r\n    t1 : float\r\n        Final time of solution.\r\n    dt : float\r\n        Time step length.\r\n    xi : float\r\n        Initial value of solution.\r\n    pars : array-like\r\n        List of parameters passed to ODE function f.\r\n    Returns:\r\n    --------\r\n    t : array-like\r\n        Independent variable solution vector.\r\n    x : array-like\r\n        Dependent variable solution vector.\r\n    Notes:\r\n    ------\r\n    Assume that ODE function f takes the following inputs, in order:\r\n        1. independent variable\r\n        2. dependent variable\r\n        3. forcing term, q\r\n        4. all other parameters\r\n    \"\"\"\r\n\r\n    # set an arbitrary initial value of q for benchmark solution\r\n    q = -1.0\r\n\r\n    if pars is None:\r\n        pars = []\r\n\r\n    # calculate the time span\r\n    tspan = t1 - t0\r\n    # use floor rounding to calculate the number of variables\r\n    n = int(tspan // dt)\r\n\r\n    # initialise the independent and dependent variable solution vectors\r\n    x = [xi]\r\n    t = [t0]\r\n\r\n    # perform Improved Euler to calculate the independent and dependent variable solutions\r\n    for i in range(n):\r\n        f0 = f(t[i], x[i], q, *pars)\r\n        f1 = f(t[i] + dt, x[i] + dt * f0, q, *pars)\r\n        x.append(x[i] + dt * (f0 / 2 + f1 / 2))\r\n        t.append(t[i] + dt)\r\n\r\n    return t, x\r\n\r\n\r\n\r\n# This function defines your ODE as a numerical function suitable for calling 'curve_fit' in scipy.\r\ndef x_curve_fitting(t, a, b, c):\r\n    \"\"\" Function designed to be used with scipy.optimize.curve_fit which solves the ODE using the Improved Euler Method.\r\n        Parameters:\r\n        -----------\r\n        t : array-like\r\n            Independent time variable vector\r\n        a : float\r\n            mass injection strength parameter.\r\n        b : float\r\n            recharge strength parameter.\r\n        c : float\r\n            saltwater intrusion strength parameter.\r\n        Returns:\r\n        --------\r\n        x : array-like\r\n            Dependent variable solution vector.\r\n        \"\"\"\r\n    # model parameters\r\n    pars = [a, b, c]\r\n\r\n    # ambient value of dependent variable\r\n    x0 = 0.304\r\n    x1 = 0.101\r\n\r\n    # time vector information\r\n    n = len(t)\r\n    dt = t[1] - t[0]\r\n\r\n    # read in time and dependent variable information\r\n    [t, x_exact] = [load_data()[2], load_data()[3]]\r\n\r\n    # initialise x\r\n    x = [x_exact[0]]\r\n\r\n    # read in q data\r\n    [t_q, q] = [load_data()[0], load_data()[1]]\r\n\r\n    # using interpolation to find the injection rate at each point in time\r\n    # MIGHT NOT BE NEEDED, as time step of q data is same as P data\r\n    q = np.interp(t, t_q, q)\r\n\r\n    # using the improved euler method to solve the ODE\r\n    for i in range(n - 1):\r\n        f0 = ode_model(t[i], x[i], q[i], *pars, x0, x1)\r\n        f1 = ode_model(t[i] + dt, x[i] + dt * f0, q[i], *pars, x0, x1)\r\n        x.append(x[i] + dt * (f0 / 2 + f1 / 2))\r\n\r\n    return x\r\n\r\n\r\n# This function calls 'curve_fit' to improve your parameter guess.\r\ndef x_pars(pars_guess):\r\n    \"\"\" Uses curve fitting to calculate required parameters to fit ODE equation\r\n    Parameters\r\n    ----------\r\n    pars_guess : array-like\r\n        Initial parameters guess\r\n    Returns\r\n    -------\r\n    pars : array-like\r\n           Array consisting of a: mass injection strength parameter, b: recharge strength parameter, c: saltwater intrusion strength parameter\r\n    \"\"\"\r\n    # read in time and dependent variable data\r\n    [t_exact, x_exact] = [load_data()[2], load_data()[3]]\r\n\r\n    # finding model constants in the formulation of the ODE using curve fitting\r\n    # optimised parameters (pars) and covariance (pars_cov) between parameters\r\n    try:\r\n        pars, pars_cov = curve_fit(x_curve_fitting, t_exact, x_exact, pars_guess, bounds=([-np.inf, -np.inf, -np.inf], [np.inf, np.inf, np.inf]))\r\n    except:\r\n        pars = [0, 0, 0]\r\n        pars_cov = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\r\n\r\n    return pars, pars_cov\r\n\r\n\r\ndef solve_ode_prediction(f, t0, t1, dt, pi, q, a, b, c, p0, p1, mp=0.0):\r\n    \"\"\" Solve the pressure prediction ODE model using the Improved Euler Method.\r\n    Parameters:\r\n    -----------\r\n    f : callable\r\n        Function that returns dxdt given variable and parameter inputs.\r\n    t0 : float\r\n        Initial time of solution.\r\n    t1 : float\r\n        Final time of solution.\r\n    dt : float\r\n        Time step length.\r\n    pi : float\r\n        Initial value of solution.\r\n    q : float\r\n        Extraction rate\r\n    a : float\r\n        mass injection strength parameter.\r\n    b : float\r\n        recharge strength parameter.\r\n    c : float\r\n        saltwater intrusion strength parameter.\r\n    p0 : float\r\n        Freshwater spring pressure.\r\n    p1 : float\r\n        Ocean pressure.\r\n    mp : float (optional)\r\n        Amount q increases by each year.\r\n    Returns:\r\n    --------\r\n    t : array-like\r\n        Independent variable solution vector.\r\n    p : array-like\r\n        Dependent variable solution vector.\r\n    Notes:\r\n    ------\r\n    Assume that ODE function f takes the following inputs, in order:\r\n        1. independent variable\r\n        2. dependent variable\r\n        3. forcing term, q\r\n        4. all other parameters\r\n    \"\"\"\r\n\r\n    # finding the number of time steps\r\n    tspan = t1 - t0\r\n    n = int(tspan // dt)\r\n\r\n    # initialising the time and solution vectors\r\n    p = [pi]\r\n    t = [t0]\r\n\r\n    # calculate increment length\r\n    incr = mp * dt\r\n\r\n    # using the improved euler method to solve the pressure ODE\r\n    for i in range(n):\r\n        q = q + (n * incr)\r\n        f0 = f(t[i], p[i], q, a, b, c, p0, p1)\r\n        f1 = f(t[i] + dt, p[i] + dt * f0, q, a, b, c, p0, p1)\r\n        p.append(p[i] + dt * (f0 / 2 + f1 / 2))\r\n        t.append(t[i] + dt)\r\n\r\n    return t, p\r\n\r\n\r\n# This function plots your model over the data using your estimate for a and b\r\ndef plot_suitable():\r\n    fig, (ax1, ax2) = plt.subplots(2, 1)\r\n\r\n    # read in time and pressure data\r\n    [t, p_exact] = [load_data()[2], load_data()[3]]\r\n\r\n    # TYPE IN YOUR PARAMETER ESTIMATE FOR a, b and c HERE\r\n    pars = [0.00142612, 1.06950873, 0.93049225]\r\n  \r\n    # solve ODE with estimated parameters and plot \r\n    p = x_curve_fitting(t, *pars)\r\n    ax1.plot(t, p_exact, 'k.', label='Observation')\r\n    ax1.plot(t, p, 'r-', label='Curve Fitting Model')\r\n    ax1.set_ylabel('Pressure of aquifer (MPa)')\r\n    ax1.set_xlabel('Time (years)')\r\n    ax1.legend()\r\n\r\n    # compute the model misfit and plot\r\n    misfit = p\r\n    for i in range(len(p)):\r\n        misfit[i] = p_exact[i] - p[i]\r\n    ax2.plot(t, misfit, 'x', label='misfit', color='r')\r\n    ax2.set_ylabel('Pressure misfit (MPa)')\r\n    ax2.set_xlabel('Time (years)')\r\n    plt.axhline(y=0, color='k', linestyle='-')\r\n    ax2.legend()\r\n\r\n    plt.tight_layout(pad=0.4, w_pad=0.5, h_pad=1.0)\r\n    plt.show()\r\n\r\n\r\n# This function plots your model over the data using your improved model after curve fitting.\r\ndef plot_improve(a, b, c):\r\n    fig, (ax1, ax2) = plt.subplots(2, 1)\r\n\r\n    # read in time and pressure data\r\n    [t, p_exact] = [load_data()[2], load_data()[3]]\r\n\r\n    # TYPE IN YOUR PARAMETER GUESS FOR a, b and c HERE AS A START FOR OPTIMISATION\r\n    pars_guess = [a, b, c]\r\n    # a = 0.00327\r\n    # b = 0.147\r\n    # c = 0.0147\r\n    \r\n    # call to find out optimal parameters using guess as start\r\n    pars, pars_cov = x_pars(pars_guess)\r\n\r\n    # check new optimised parameters\r\n    print (\"Improved a, b and c: \", pars)\r\n\r\n    # solve ODE with new parameters and plot \r\n    p = x_curve_fitting(t, *pars)\r\n\r\n    ax1.plot(t, p_exact, 'k.', label='Observation')\r\n    ax1.plot(t, p, 'r-', label='Curve Fitting Model')\r\n    ax1.set_ylabel('Pressure (MPa)')\r\n    ax1.set_xlabel('Time (years)')\r\n    ax1.legend()\r\n\r\n    # compute the model misfit and plot\r\n    misfit = p\r\n    total_misfit = 0\r\n    for i in range(len(p)):\r\n        misfit[i] = p_exact[i] - p[i]\r\n        total_misfit += misfit[i] ** 2\r\n    print(\"Total misfit: \", total_misfit)\r\n\r\n    ax2.plot(t, misfit, 'x', label='misfit', color='r')\r\n    ax2.set_ylabel('Pressure misfit (MPa)')\r\n    ax2.set_xlabel('Time (years)')\r\n    plt.axhline(y=0, color='k', linestyle='-')\r\n    ax2.legend()\r\n\r\n    plt.tight_layout(pad=0.4, w_pad=0.5, h_pad=1.0)\r\n    plt.show()\r\n\r\n    return total_misfit\r\n\r\n\r\n# GRADIENT DESCENT\r\ndef grad_descent():\r\n    # parameter vector - initial guess of minimum location\r\n    theta0 = np.array([0.00327, 2.496, 0.499])\r\n    # compute steepest descent direction\r\n    s0 = obj_dir(obj, theta0)\r\n    # plot 1: compare against lab2_instructions.pdf, Figure 1 \r\n    plot_s0(obj, theta0, s0)\r\n    return\r\n    \r\n    # choose step size \r\n    alpha = 0.5\r\n    # update parameter estimate\r\n    theta1 = step(theta0, s0, alpha)\r\n    # plot 2: compare against lab2_instructions.pdf, Figure 2 \r\n    #plot_step(obj, theta0, s0, theta1)\r\n    #return\r\n    \r\n    # Get the new Jacobian for the last parameters estimation\r\n    s1 = obj_dir(obj, theta1)\r\n    # plot 3: compare against lab2_instructions.pdf, Figure 3 \r\n    #plot_s1(obj, theta0, s0, theta1, s1)\r\n    #return\r\n    \r\n    # Plot iterations\r\n    # The following script repeats the process until an optimum is reached, or until the maximum number of iterations allowed is reached\r\n    # Try with different gammas to see how it impacts the optimization process \r\n    # Uncomment line 47 to use a line search algorithm\r\n    theta_all = [theta0]\r\n    s_all = [s0]\r\n    # iteration control\r\n    N_max = 30\r\n    N_it = 0\r\n    # begin steepest descent iterations\r\n        # exit when max iterations exceeded\r\n    while N_it < N_max:\r\n        # uncomment line below to implement line search\r\n        alpha = line_search(obj, theta_all[-1], s_all[-1])\r\n        # update parameter vector \r\n        theta_next = step(theta0, s0, alpha)\r\n        theta_all.append(theta_next) \t# save parameter value for plotting\r\n        # compute new direction for line search (thetas[-1]\r\n        s_next = obj_dir(obj, theta_next)\r\n        s_all.append(s_next) \t\t\t# save search direction for plotting\r\n        # compute magnitude of steepest descent direction for exit criteria\r\n        N_it += 1\r\n        # restart next iteration with values at end of previous iteration\r\n        theta0 = 1.*theta_next\r\n        s0 = 1.*s_next\r\n    \r\n    print('Optimum a, b, c: ', round(theta_all[-1][0], 2), round(theta_all[-1][1], 2), round(theta_all[-1][2], 3))\r\n    print('Number of iterations needed: ', N_it)\r\n\r\n    # plot 4: compare against lab2_instructions.pdf, Figure 4 \r\n    #plot_steps(obj, theta_all, s_all)\r\n    #return theta_all[-1]\r\n\r\n\r\n# This function plots your model against a benchmark analytic solution.\r\ndef plot_benchmark():\r\n    \"\"\" Compare analytical and numerical solutions via plotting.\r\n\r\n    Parameters:\r\n    -----------\r\n    none\r\n\r\n    Returns:\r\n    --------\r\n    none\r\n\r\n    \"\"\"\r\n    # values for benchmark solution\r\n    t0 = 0\r\n    t1 = 10\r\n    dt = 0.1\r\n\r\n    # model values for benchmark analytic solution\r\n    a = 1\r\n    b = 1\r\n    c = 1\r\n\r\n    # set ambient values to zero for benchmark analytic solution\r\n    p0 = 0\r\n    p1 = 0\r\n    # set inital value to zero for benchmark analytic solution\r\n    pi = 0\r\n\r\n    # set extraction rate to a constant\r\n    q0 = 1\r\n\r\n    # setup parameters array with constants\r\n    pars = [a, b, c, p0, p1]\r\n\r\n    fig, plot = plt.subplots(nrows=1, ncols=3, figsize=(13, 5))\r\n\r\n    # Solve ODE and plot\r\n    t, p = solve_ode(ode_model, t0, t1, dt, pi, pars)\r\n    plot[0].plot(t, p, \"bx\", label=\"Numerical Solution\")\r\n    plot[0].set_ylabel(\"Pressure [MPa]\")\r\n    plot[0].set_xlabel(\"t\")\r\n    plot[0].set_title(\"Benchmark\")\r\n\r\n    # Analytical Solution\r\n    t = np.array(t)\r\n\r\n#   TYPE IN YOUR ANALYTIC SOLUTION HERE\r\n#   if P = 0 at t = 0:\r\n    p_analytical = -((b * p0 + c * p1 - a * q0) / (b + c)) * (1 - np.exp(-(b + c) * t))\r\n\r\n    plot[0].plot(t, p_analytical, \"r-\", label=\"Analytical Solution\")\r\n    plot[0].legend(loc=1)\r\n\r\n    # Plot error\r\n    p_error = []\r\n    for i in range(1, len(p)):\r\n        if (p[i] - p_analytical[i]) == 0:\r\n            p_error.append(0)\r\n            print(\"check line Error Analysis Plot section\")\r\n        else:\r\n            p_error.append((np.abs(p[i] - p_analytical[i]) / np.abs(p_analytical[i])))\r\n    plot[1].plot(t[1:], p_error, \"k*\")\r\n    plot[1].set_ylabel(\"Relative Error Against Benchmark\")\r\n    plot[1].set_xlabel(\"t\")\r\n    plot[1].set_title(\"Error Analysis\")\r\n    plot[1].set_yscale(\"log\")\r\n\r\n    # Timestep convergence plot\r\n    time_step = np.flip(np.linspace(1/5, 1, 13))\r\n    for i in time_step:\r\n        t, p = solve_ode(ode_model, t0, t1, i, p0, pars)\r\n        plot[2].plot(1 / i, p[-1], \"kx\")\r\n\r\n    plot[2].set_ylabel(f\"Pressure(t = {10})\")\r\n    plot[2].set_xlabel(\"1/\\u0394t\")\r\n    plot[2].set_title(\"Timestep Convergence\")\r\n\r\n    # plot spacings\r\n    fig.tight_layout()\r\n    plt.subplots_adjust(wspace=0.3)\r\n    plt.show()\r\n\r\n\r\ndef plot_x_forecast():\r\n    ''' Plot the ODE LPM model over the given data plot with different q-value scenario for predictions.\r\n    Use a curve fitting function to accurately define the optimum parameter values.\r\n    Parameters:\r\n    -----------\r\n    none\r\n    Returns:\r\n    --------\r\n    none\r\n    '''\r\n\r\n    # Read in time and dependent variable data\r\n    [t, p_exact] = [load_data()[2], load_data()[3]]\r\n\r\n    # GUESS PARAMETERS HERE\r\n    pars_guess = [5.46588224e-08,  7.06532189, -6.06545369]\r\n\r\n    # Optimise parameters for model fit\r\n    pars, pars_cov = x_pars(pars_guess)\r\n\r\n    # Store optimal values for later use\r\n    [a, b, c] = pars\r\n\r\n    # Solve ODE and plot model\r\n    p = x_curve_fitting(t, *pars)\r\n    f, ax1 = plt.subplots()\r\n    ax1.plot(t, p_exact, 'r.', label='data')\r\n    ax1.plot(t, p, 'black', label='Model')\r\n\r\n    # Remember the last time\r\n    t_end = t[-1]\r\n\r\n    # Create forecast time with 20 new time steps\r\n    t1 = []\r\n    for i in range(5):\r\n        t1.append(i + t_end)\r\n\r\n    # Set initial and ambient values for forecast\r\n    pi = p[-1]  # Initial value of x is final value of model fit\r\n    p0 = 0.3  # Ambient value of spring pressure\r\n    p_ocean = 0.1  # Ambient value of ocean pressure\r\n\r\n    # Solve ODE prediction for scenario 1: 'Continue extracting at an increasing rate as seen from the past five years.'\r\n    # multiplier (5.71e4) is the average increase in q from 2014 - 2019\r\n    # q1 = 2.65e7 # average q from 2014 - 2019\r\n    # p1 = solve_ode_prediction(ode_model, t1[0], t1[-1], t1[1] - t1[0], pi, q1, a, b, c, p0, p_ocean, 5.71e4)[1]\r\n    # ax1.plot(t1, p1, 'purple', label='extract @ incr rate')\r\n\r\n    q1 = 5.71e7 # 2x average q from 2014 - 2019\r\n    p1 = solve_ode_prediction(ode_model, t1[0], t1[-1], t1[1] - t1[0], pi, q1, a, b, c, p0, p_ocean)[1]\r\n    ax1.plot(t1, p1, 'purple', label='extract @ incr rate')\r\n\r\n    # Solve ODE prediction for scenario 2: 'Extract at the current rate and no higher.'\r\n    q2 = 2.65e7 # average q from 2014 - 2019\r\n    p2 = solve_ode_prediction(ode_model, t1[0], t1[-1], t1[1] - t1[0], pi, q2, a, b, c, p0, p_ocean)[1]\r\n    ax1.plot(t1, p2, 'green', label='extract @ current rate')\r\n\r\n    # Solve ODE prediction for scenario 3: 'Extract at a reduced rate and continue no higher.'\r\n    q3 = 1.33e7 # ~half average q from 2014 - 2019\r\n    p3 = solve_ode_prediction(ode_model, t1[0], t1[-1], t1[1] - t1[0], pi, q3, a, b, c, p0, p_ocean)[1]\r\n    ax1.plot(t1, p3, 'blue', label='extract @ decr rate')\r\n\r\n    # Solve ODE prediction for scenario 4: 'Extract at a decreasing rate until pressures stabilise to the level seen\r\n    # between 2000 and 2010.'\r\n    # multiplier (-3e5) i chose manually, there's no condition checking for a stable P or anything..\r\n    # q4 = 2.65e7 # average q from 2014 - 2019\r\n    # p4 = solve_ode_prediction(ode_model, t1[0], t1[-1], t1[1] - t1[0], pi, q4, a, b, c, p0, p_ocean, -3e5)[1]\r\n    # ax1.plot(t1, p4, 'red', label='extract @ decr rate until P stable')\r\n\r\n    # Solve ODE prediction for scenario 5: 'Halt the extraction until pressures stabilise to the level seen between\r\n    # 2000 and 2010.'\r\n    q5 = 0\r\n    p5 = solve_ode_prediction(ode_model, t1[0], t1[-1], t1[1] - t1[0], pi, q5, a, b, c, p0, p_ocean)[1]\r\n    ax1.plot(t1, p5, 'pink', label='no extraction')\r\n\r\n    # Axis information\r\n    ax1.set_title('Pressure Forcast')\r\n    ax1.set_ylabel('Pressure (MPa)')\r\n    ax1.set_xlabel('Time (years)')\r\n    ax1.legend()\r\n    plt.show()\r\n\r\n# This function computes uncertainty in your model\r\ndef plot_x_uncertainty():\r\n    \"\"\"\r\n    This function plots the uncertainty of the ODE model.\r\n    \"\"\"\r\n\r\n    # read in time and dependent variable data\r\n    [t, p_exact] = [load_data()[2], load_data()[3]]\r\n\r\n    # GUESS PARAMETERS HERE\r\n    pars_guess = [5.46588224e-08,  7.06532189, -6.06545369]\r\n\r\n    # Optimise parameters for model fit\r\n    pars, pars_cov = x_pars(pars_guess)\r\n\r\n    # Store optimal values for later use\r\n    [a,b,c] = pars\r\n\r\n    # Solve ODE and plot model\r\n    p = x_curve_fitting(t, *pars)\r\n    figa, ax1 = plt.subplots()\r\n    ax1.plot(t, p_exact, 'r.', label='data')\r\n    ax1.plot(t, p, 'black', label='Model')\r\n\r\n    # Remember the last time\r\n    t_end = t[-1]\r\n\r\n    # Create forecast time with 400 new time steps\r\n    t1 = []\r\n    for i in range(5):\r\n        t1.append(i+t_end)\r\n\r\n    # Set initial and ambient values for forecast\r\n    pi = p[-1] # Initial value of x is final value of model fit\r\n    p0 = 0.3 # Ambient value of\r\n    p_ocean = 0.1\r\n\r\n    q1 = 5.71e7 # 2x average q from 2014 - 2019\r\n    p1 = solve_ode_prediction(ode_model, t1[0], t1[-1], t1[1] - t1[0], pi, q1, a, b, c, p0, p_ocean)[1]\r\n    ax1.plot(t1, p1, 'purple', label='extract @ incr rate')\r\n\r\n    # Solve ODE prediction for scenario 2: 'Extract at the current rate and no higher.'\r\n    q2 = 2.65e7 # average q from 2014 - 2019\r\n    p2 = solve_ode_prediction(ode_model, t1[0], t1[-1], t1[1] - t1[0], pi, q2, a, b, c, p0, p_ocean)[1]\r\n    ax1.plot(t1, p2, 'green', label='extract @ current rate')\r\n\r\n    # Solve ODE prediction for scenario 3: 'Extract at a reduced rate and continue no higher.'\r\n    q3 = 1.33e7 # ~half average q from 2014 - 2019\r\n    p3 = solve_ode_prediction(ode_model, t1[0], t1[-1], t1[1] - t1[0], pi, q3, a, b, c, p0, p_ocean)[1]\r\n    ax1.plot(t1, p3, 'blue', label='extract @ decr rate')\r\n\r\n    # Solve ODE prediction for scenario 4: 'Extract at a decreasing rate until pressures stabilise to the level seen\r\n    # between 2000 and 2010.'\r\n    # multiplier (-3e5) i chose manually, there's no condition checking for a stable P or anything..\r\n    # q4 = 2.65e7 # average q from 2014 - 2019\r\n    # p4 = solve_ode_prediction(ode_model, t1[0], t1[-1], t1[1] - t1[0], pi, q4, a, b, c, p0, p_ocean, -3e5)[1]\r\n    # ax1.plot(t1, p4, 'red', label='extract @ decr rate until P stable')\r\n\r\n    # Solve ODE prediction for scenario 5: 'Halt the extraction until pressures stabilise to the level seen between\r\n    # 2000 and 2010.'\r\n    q5 = 0\r\n    p5 = solve_ode_prediction(ode_model, t1[0], t1[-1], t1[1] - t1[0], pi, q5, a, b, c, p0, p_ocean)[1]\r\n    ax1.plot(t1, p5, 'pink', label='no extraction')\r\n\r\n    # Estimate the variability of parameter b\r\n    # We are assuming that parameter b has the biggest source of error in the system\r\n    # (you could choose another parameter if you like)\r\n    var = 0.1\r\n\r\n    # using Normal function to generate 500 random samples from a Gaussian distribution\r\n    b_samples = np.random.normal(b, var, 500)\r\n    c_samples = np.random.normal(c, var, 500)\r\n\r\n    # initialise list to count parameters for histograms\r\n    b_list = []\r\n    c_list = []\r\n\r\n    # loop to plot the different predictions with uncertainty\r\n    for i in range(0,499): # 500 samples are 0 to 499\r\n        # frequency distribution for histograms for parameters\r\n        b_list.append(b_samples[i])\r\n        c_list.append(c_samples[i])\r\n\r\n        # Solve model fit with uncertainty\r\n        spars = [a, b_samples[i], c_samples[i]]\r\n        p = x_curve_fitting(t, *spars)\r\n        ax1.plot(t, p, 'black', alpha=0.1, lw=0.5)\r\n\r\n        # Solve ODE prediction for scenario 1 with uncertainty\r\n        q1 = 5.71e7  # 2x average q from 2014 - 2019\r\n        p1 = solve_ode_prediction(ode_model, t1[0], t1[-1], t1[1] - t1[0], pi, q1, a, b_samples[i], c_samples[i], p0, p_ocean)[1]\r\n        ax1.plot(t1, p1, 'purple', alpha=0.1, lw=0.5)\r\n\r\n        # Solve ODE prediction for scenario 2 with uncertainty\r\n        q2 = 2.65e7  # average q from 2014 - 2019\r\n        p2 = solve_ode_prediction(ode_model, t1[0], t1[-1], t1[1] - t1[0], pi, q2, a, b_samples[i], c_samples[i], p0, p_ocean)[1]\r\n        ax1.plot(t1, p2, 'green', alpha=0.1, lw=0.5)\r\n\r\n        # Solve ODE prediction for scenario 3 with uncertainty\r\n        q3 = 1.33e7  # ~half average q from 2014 - 2019\r\n        p3 = solve_ode_prediction(ode_model, t1[0], t1[-1], t1[1] - t1[0], pi, q3, a, b_samples[i], c_samples[i], p0, p_ocean)[1]\r\n        ax1.plot(t1, p3, 'blue', alpha=0.1, lw=0.5)\r\n\r\n        # Solve ODE prediction for scenario 4 with uncertainty\r\n        q4 = 0  # 0\r\n        p4 = solve_ode_prediction(ode_model, t1[0], t1[-1], t1[1] - t1[0], pi, q4, a, b_samples[i], c_samples[i], p0, p_ocean)[1]\r\n        ax1.plot(t1, p4, 'pink', alpha=0.1, lw=0.5)\r\n\r\n    ax1.set_title('Pressure Uncertainty Forecast')\r\n    ax1.set_ylabel('Pressure (MPa)')\r\n    ax1.set_xlabel('Time (years)')\r\n    ax1.legend()\r\n\r\n    # plotting the histograms\r\n    figb, (ax2) = plt.subplots(1, 1)\r\n    num_bins = 30\r\n    ax2.hist(b_list, num_bins)\r\n    ax2.set_title(\"Frequency Density plot for Parameter b\", fontsize=9)\r\n    ax2.set_xlabel('Parameter b', fontsize=9)\r\n    ax2.set_ylabel('Frequency density', fontsize=9)\r\n    a_yf5, a_yf95 = np.percentile(b_list, [5, 95])\r\n    ax2.axvline(a_yf5, label='95% interval', color='r', linestyle='--')\r\n    ax2.axvline(a_yf95, color='r', linestyle='--')\r\n    ax2.legend(loc=0, fontsize=9)\r\n\r\n    plt.tight_layout(pad=0.4, w_pad=0.5, h_pad=1.0)\r\n    plt.show()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ode.py b/ode.py
--- a/ode.py	(revision 443a5cee80b60bdccec8353c1c44eb7a4a912aec)
+++ b/ode.py	(date 1697058401851)
@@ -298,7 +298,7 @@
     [t, p_exact] = [load_data()[2], load_data()[3]]
 
     # TYPE IN YOUR PARAMETER ESTIMATE FOR a, b and c HERE
-    pars = [0.00142612, 1.06950873, 0.93049225]
+    pars = [3.271e-9, 0.421, 0.0421]
   
     # solve ODE with estimated parameters and plot 
     p = x_curve_fitting(t, *pars)
Index: main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from ode import *\r\n\r\nif __name__ == \"__main__\":\r\n    # benchmarking for ODE\r\n    # plot_benchmark()\r\n\r\n    #grad_descent()\r\n\r\n    # ODE model with initial parameter values\r\n    # plot_suitable()\r\n\r\n    # ODE model with improved parameter values from curve_fit\r\n    # plot_improve(0.00327, 0.147, 0.0147)\r\n\r\n    # Try and find best b and c values\r\n    # min_misfit = np.inf\r\n    # best_b = 0\r\n    # best_c = 0\r\n    # for b in np.arange(0, 1, 0.1):\r\n    #     for c in np.arange(0, 1, 0.1):\r\n    #         try:\r\n    #             total_misfit = plot_improve(0.00327, b, c)\r\n    #             if total_misfit < min_misfit:\r\n    #                 min_misfit = total_misfit\r\n    #                 best_b = b\r\n    #                 best_c = c\r\n    #         except:\r\n    #             pass\r\n    # print(\"Best b: \", best_b)\r\n    # print(\"Best c: \", best_c)\r\n\r\n    plot_x_forecast()\r\n    plot_x_uncertainty()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.py b/main.py
--- a/main.py	(revision 443a5cee80b60bdccec8353c1c44eb7a4a912aec)
+++ b/main.py	(date 1697063901472)
@@ -2,15 +2,15 @@
 
 if __name__ == "__main__":
     # benchmarking for ODE
-    # plot_benchmark()
+    plot_benchmark()
 
     #grad_descent()
 
     # ODE model with initial parameter values
-    # plot_suitable()
+    plot_suitable()
 
     # ODE model with improved parameter values from curve_fit
-    # plot_improve(0.00327, 0.147, 0.0147)
+    plot_improve(0.00327, 0.147, 0.0147)
 
     # Try and find best b and c values
     # min_misfit = np.inf
@@ -29,5 +29,5 @@
     # print("Best b: ", best_b)
     # print("Best c: ", best_c)
 
-    plot_x_forecast()
+    #plot_x_forecast()
     plot_x_uncertainty()
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.10 (LAB1 233)\" project-jdk-type=\"Python SDK\" />\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	(revision 443a5cee80b60bdccec8353c1c44eb7a4a912aec)
+++ b/.idea/misc.xml	(date 1697063946806)
@@ -1,4 +1,4 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.10 (LAB1 233)" project-jdk-type="Python SDK" />
+  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.11" project-jdk-type="Python SDK" />
 </project>
\ No newline at end of file
